# Проект (пока без названия)
Это проект анонимного электронного голосования.

## ВАЖНО!
Код, написанный мной, находится в перечисленных каталогах:
- ./mysite/ (сайт на Django)
- ./venv/lib/python3.10/site-packages/project_package/ (модули, необходимые для работы проекта)

Проект и его описание находятся на стадии активного рефакторинга, многочисленных исправлений и доработок.
Например существует проблема с именованием сложных переменных типа `s_m_l_h_e_emek_e_eaek_b`,
что расшифровывается как подписанный посредником список хешей бюллетеней, зашифрованных общим ключом голосующего и агенства,
к которым приложены эти ключи в зашифрованном виде и бла-бла-бла.
Вопрос: как придумать этому человеческое и при этом говорящее само за себя название?
Уже начал думать над решением это проблемы.

Описание проекта может быть труднопонятным, со временем это изменится.
Как говорится, сделать сложно - просто, а вот сделать просто - сложно.

## Глоссарий
В коде повсеместно используются переменные, именуемые по особой схеме ради информативности и компактности.
Ниже представлена расшифровка как простых имён переменных, так и их составных частей.

- `v` - voting.
- `v_id` - voting ID.
- `b` - ballot.
- `e` - elector.
- `m` - mediator.
- `a` - agency.
- `w` - website.
- `pk` - public key.
- `sk` - secret key.
- `sign_pk` - публичный ключ для подписи.
- `kem_pk` - публичный ключ механизма инкапсуляции ключей.
- `a_sign_pk` - публичный ключ для подписи, принадлежащий агенству.
- `rfp` - RFP (request for participation), запрос на участие в голосовании.
- `lvp` - LVP (legitimate voting participants), список легитимных участников голосования.
- Префикс `e` - означает "encrypted", т.е. зашифрованный.
Всегда используется с указанием зашифрованной сущности и владельцев общего ключа шифрования.
Например `e_ea_b` означает бюллетень `b`, зашифрованный ключом общим для голосующего `e` и агенства `a`.
- Префикс `k` - означает "key", т.е. ключ.
Всегда используется с указанием владельцев ключа, для которых он является общим.
Например `k_em` означает ключ `k` общий для голосующего `e` и посредника `m`.
- `e_eaek_b` - означает `e_ea_b` и ключ шифрования в зашифрованном виде (`ek`).
- Префикс `s` - означает "signed".
Всегда используется с указанием автора подписи и подписанной сущности.
Например `s_a_lvp` означает LVP подписанный агенством.
- Префикс `l` - означает "list". Например `l_rfp` означает список RFP.
- Префикс `d` - означает "dict". Аналогично префиксу `l`.
- `msg_mw` - означает сообщение `msg`, у которого отправитель является посредником `m`, а получатель - веб-сайтом `w`.
- Префикс `h` - означает "hashed".
Всегда используется с указанием хешированной сущности.
Например `h_b` означает хешированный бюллетень.

Как расшифровать имя переменной `s_m_l_h_e_emek_e_eaek_b`?
Как расшифровывается `e_eaek_b` уже известно. `e_emek_e_eaek_b` это `e_eaek_b` зашифрованный ключом общим для голосующего и посредника и этот самый ключ в зашифрованном виде, приложенный к зашифрованному бюллетеню `e_eaek_b`.
`s_m_l_h_e_emek_e_eaek_b` это подписанный посредником список хешированных `e_emek_e_eaek_b`.

## Особенности проекта
Основной особенностью проекта являются созданные мной два криптографических протокола: протокол голосования и протокол аутентификации.
Ниже находится их краткое описание.

## Протокол голосования
Предполагается, что публичные ключи пользователей уже зарегистрированы и общеизвестны.

- Агенство отправляет серверу необходимые данные о голосовании.
- Голосующий создает `rfp, e_emek_e_eaek_b` и отправляет на сервер.
- Посредник скачивает с сервера `l_e_emek_e_eaek_b`, а затем публикует `s_m_l_h_e_emek_e_eaek_b`.
- Сервер формирует `l_rfp` в соответствии с `l_h_e_emek_e_eaek_b` каждого конкретного посредника.
- Посредник получает `l_rfp` от сервера, а в ответ публикует `s_m(l_rfp, l_e_eaek_b)`.
- Агенство обрабатывает `s_m(l_rfp, l_e_eaek_b)` и публикует итоги голосования,
которые состоят в том числе из списков бюллетеней и RFP в незашифрованном виде, т.е. это `l_rfp` и `l_b`.

Здесь не указаны многочисленные проверки сообщений, их формирование, способы передачи и прочие детали.
Также не указан способ регистрации и передачи голосующими своих ключей агенству или серверу, т.к. это не является целью протокола.

Протокол уникален тем, что **голосующий не подписывает собственный голос**.
Вместо этого он создает заявку на участие в голосовании (RFP) и вместе с ней отправляет свой голос дальше в соответствии с протоколом.
Единственный способ узнать, как проголосовал тот или иной участник, это организовать сговор посредника, сервера и агенства.
И даже в таком случае мошенники не смогут доказать принадлежность бюллетеня голосующему, посколько он его не подписывал.
При этом посредник или агенство не могут подменить бюллетень голосующего. Но почему? Ведь голосующий не подписывает свой бюллетень.
Дело в том, что бюллетень может участвовать в голосовании только в паре с чьим-либо RFP.
А ещё у каждого бюллетеня есть уникальный идентификатор, позволяющий проверить его подлинность. 
Посредник публикует `s_m_l_h_e_emek_e_eaek_b`,
тем самым расписываясь в том, что в голосовании могут участвовать лишь эти подписанные бюллетени.
И только после этого сервер предоставляет ему список RFP, необходимых для выполнения протокола.

В идеале сервер не должен участвовать в протоколе и все вычисления должны производиться на компьютерах участников.
Он был добавлен исключительно для удобства.

## Протокол аутентификации

Для понятного описания того, как чисто технически работает этот протокол, необходима хорошая визуализация этого процесса (будет),
поэтому я просто расскажу что он из себя представляет и какие имеет особенности.

Я действительно горжусь им, потому что этот протокол является необычной смесью S/Key и HMAC,
т.е. одноразовых ключей и кодов аутентификации сообщений, основанных на хеш-функциях.
Протокол обладает всеми плюсами системы одноразовых ключей.
При этом число одноразовых ключей для одного секретного ключа может быть **абсолютно любым при одинаково высокой скорости вычислений**
(в моём проекте максимальное число ключей равно 2^32 и **каждый** создается при помощи всего лишь 2^8 итераций хеш-функции).

Вычислительные мощности злоумышленников растут с каждым годом, а вот способность пользователей запоминать свои пароли...
Большинство людей (по моим опросам) либо используют один пароль для всего, либо разные, но записанные в блокнот.
Задачу по созданию и хранению надежного пароля протокол берёт на себя.
Всё, что нужно сделать пользователю, это скачать специальную программу с сайта,
которая создаст секретный файл с ключом с энтропией 256 бит и парой ключей для подписи и хранить этот файл в надёжном месте.
А процесс аутентификации происходит буквально в два счёта.
Пользователь загружает в программу свой секретный файл и с её помощью генерирует одноразовые ключи для входа на сайт
(а в будущем и для других определенных действий).
