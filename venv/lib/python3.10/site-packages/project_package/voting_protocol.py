from Crypto.Random import get_random_bytes
from .ciphertext import Ciphertext
from .hash_data import hash_data
from .message import *
from .voting import Voting
from .ballot import Ballot
from pprint import pprint
from .files import *
from .sign import Sign
from .lvp import LVP
from .key import Key
import random
import sys
import os


__all__ = [
	'create_voting',
	'create_msg_em',
	'create_msg_mw',
	'create_msg_ma',
	'create_msg_voting_summary'
]


def create_voting(l_vp_sign_pk, a_keys, voting_text):

	question = voting_text['question']
	description = voting_text['description']
	options = voting_text['options']

	a_sign_pk = a_keys['sign_pk']
	a_sign_sk = a_keys['sign_sk']
	a_kem_pk = a_keys['kem_pk']

	v = Voting(a_sign_pk, a_kem_pk, question, description, options)
	v_id = v.get_v_id()
	lvp = LVP(l_vp_sign_pk, v_id)
	s_a_lvp = Sign(lvp, a_sign_pk, a_sign_sk)
	v.set_s_a_lvp(s_a_lvp)

	return v


def create_msg_em(
	v,
	b,
	e_keys
):

	e_sign_pk = e_keys['sign_pk']
	e_sign_sk = e_keys['sign_sk']
	e_kem_pk = e_keys['kem_pk']
	v_keys = v.get_keys()
	m_sign_pk = v_keys['d_sel_m_pk']['m_sign_pk']
	m_kem_pk = v_keys['d_sel_m_pk']['m_kem_pk']
	a_sign_pk = v_keys['a_sign_pk']
	a_kem_pk = v_keys['a_kem_pk']

	s_a_lvp = v.get_s_a_lvp()
	if not s_a_lvp.verify() or s_a_lvp.get_author_pk() != a_sign_pk:
		raise Exception('подпись не прошла проверку')
	if not s_a_lvp.get_data().check(e_sign_pk):
		raise Exception('человек с таким e_sign_pk не может участвовать в этом голосовании')
	if s_a_lvp.get_data().get_v_id() != v.get_v_id():
		raise Exception('идентификаторы голосования у LVP и объекта голосования не совпадают')
	if m_sign_pk not in v_keys['d_m_pk'] or m_kem_pk not in v_keys['d_m_pk'].values():
		raise Exception(f'\nЭтого посредника {m_sign_pk[0:8].hex()} нет в списке зарегистрированных посредников.')

	rfp = Sign(v.get_v_id(), e_sign_pk, e_sign_sk)

	k_ea = get_random_bytes(32)
	e_eaek_b = {
		'e_ea_b': Ciphertext(b, k_ea),
		'ek_ea': Key(k_ea, a_sign_pk, a_kem_pk)
	}

	k_em = get_random_bytes(32)
	e_emek_e_eaek_b = {
		'e_em_e_eaek_b': Ciphertext(e_eaek_b, k_em),
		'ek_em': Key(k_em, m_sign_pk, m_kem_pk)
	}

	return {
		'msg_em': MsgEM(rfp, e_emek_e_eaek_b),
		'e_eaek_b': e_eaek_b,
		's_a_lvp': s_a_lvp,
		'm_sign_pk': m_sign_pk,
		'm_kem_pk': m_kem_pk,
		'a_sign_pk': a_sign_pk,
		'a_kem_pk': a_kem_pk,
		'v': v,
		'b': b,
		'k_em': k_em,
		'k_ea': k_ea
	}


def create_msg_mw(v, msg_wm_1, m_keys):

	if not msg_wm_1.check():
		raise Exception('msg_wm_1 не прошло проверку')

	m_sign_pk = m_keys['sign_pk']
	m_sign_sk = m_keys['sign_sk']
	m_kem_sk = m_keys['kem_sk']
	a_sign_pk, a_kem_pk = v.get_keys()['a_sign_pk'], v.get_keys()['a_kem_pk']

	l_h_e_emek_e_eaek_b, l_e_eaek_b = _process_msg_wm_1(msg_wm_1, m_kem_sk, a_sign_pk, a_kem_pk)

	return {
		'msg_mw': MsgMW(l_h_e_emek_e_eaek_b, m_sign_pk, m_sign_sk),
		'msg_wm_1': msg_wm_1,
		'l_e_eaek_b': sorted(l_e_eaek_b, key=lambda x: hash_data(x)),
		'a_sign_pk': a_sign_pk,
		'a_kem_pk': a_kem_pk,
		'v': v
	}


def _process_msg_wm_1(msg_wm_1, m_kem_sk, a_sign_pk, a_kem_pk):

	l_h_e_emek_e_eaek_b = []
	l_e_eaek_b = []
	for e_emek_e_eaek_b in msg_wm_1.get_data()['l_e_emek_e_eaek_b']:
		try:
			k_em = e_emek_e_eaek_b['ek_em'].get_key(m_kem_sk)
			e_eaek_b = e_emek_e_eaek_b['e_em_e_eaek_b'].decrypt(k_em)
			ek_ea = e_eaek_b['ek_ea']
			if ek_ea.get_recipient_keys() != (a_sign_pk, a_kem_pk):
				continue
			l_e_eaek_b.append(e_eaek_b)
			l_h_e_emek_e_eaek_b.append(hash_data(e_emek_e_eaek_b))
		except:
			continue

	return l_h_e_emek_e_eaek_b, l_e_eaek_b


def create_msg_ma(msg_wm_2, l_e_eaek_b, v_id, m_keys):

	if not msg_wm_2.check(v_id):
		raise Exception('msg_wm_2 не прошло проверку')

	l_rfp = msg_wm_2.get_data()['l_rfp']

	if len(l_rfp) != len(l_e_eaek_b):
		raise Exception('списки rfp и e_eaek_b содержат разное количество элементов')

	m_sign_pk = m_keys['sign_pk']
	m_sign_sk = m_keys['sign_sk']

	msg_ma = MsgMA(l_rfp, l_e_eaek_b, m_sign_pk, m_sign_sk)

	return {
		'msg_ma': msg_ma,
		'msg_wm_2': msg_wm_2
	}


def create_msg_voting_summary(msg_wa, v, a_keys):

	a_sign_pk = a_keys['sign_pk']
	a_sign_sk = a_keys['sign_sk']
	a_kem_sk = a_keys['kem_sk']

	voting_summary = {}
	for m_sign_pk, msg_ma in msg_wa.items():
		single_summary = _process_msg_ma(v, m_sign_pk, a_kem_sk, msg_ma)
		if single_summary != None:
			voting_summary.update(single_summary)

	return {
		'msg_voting_summary': MsgVotingSummary(voting_summary, a_sign_pk, a_sign_sk),
		'v': v
	}


def _process_msg_ma(v, m_sign_pk, a_kem_sk, msg_ma):

	if msg_ma.check(v, m_sign_pk):

		s_m_l_rfp_and_l_e_eaek_b = msg_ma.get_data()['s_m_l_rfp_and_l_e_eaek_b']
		l_rfp, l_b = _process_s_m_l_rfp_and_l_e_eaek_b(s_m_l_rfp_and_l_e_eaek_b, m_sign_pk, a_kem_sk)

		if len(l_rfp) > 0 and len(l_b) > 0:
			single_summary = {m_sign_pk: {'l_rfp': sorted(l_rfp), 'l_b': sorted(l_b)}}
			return single_summary


def _process_s_m_l_rfp_and_l_e_eaek_b(s_m_l_rfp_and_l_e_eaek_b, m_sign_pk, a_kem_sk):

	l_rfp = []
	l_b = []

	s_m_l_rfp_and_l_e_eaek_b_is_valid = s_m_l_rfp_and_l_e_eaek_b.verify() and s_m_l_rfp_and_l_e_eaek_b.get_author_pk() != m_sign_pk
	if s_m_l_rfp_and_l_e_eaek_b_is_valid:
		l_rfp += s_m_l_rfp_and_l_e_eaek_b.get_data()['l_rfp']
		l_e_eaek_b = s_m_l_rfp_and_l_e_eaek_b.get_data()['l_e_eaek_b']
		for e_eaek_b in l_e_eaek_b:
			b = _decrypt_e_eaek_b(e_eaek_b, a_kem_sk)
			if b != None:
				l_b.append(b)

	return l_rfp[0:len(l_b)], l_b


def _decrypt_e_eaek_b(e_eaek_b, a_kem_sk):
	try:
		e_ea_b, ek_ea  = e_eaek_b['e_ea_b'], e_eaek_b['ek_ea']
		k_ea = ek_ea.get_key(a_kem_sk)
		b = e_ea_b.decrypt(k_ea)
		# тут надо проверить бюллетень, например b.is_valid()
		return b
	except:
		return None
