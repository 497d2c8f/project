from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA3_256
from .hash_data import hash_data
from .serialization import serialize_to_string, deserialize_from_string
from Crypto.Random import get_random_bytes


class Ciphertext:

	def __init__(self, data, key):
		bin_data = serialize_to_string(data)
		bin_key = hash_data(key)
		cipher = self.__create_cipher(bin_key)
		self.__ciphertext = cipher.encrypt(bin_data)
		self.__hmac = self.__create_hmac().digest()

	def __lt__(self, other):
		return self.__ciphertext < other.__ciphertext

	def decrypt(self, key):
		bin_key = hash_data(key)
		cipher = self.__create_cipher(bin_key)
		self.__verify_hmac()
		decrypted_data = self.__decrypt_data(cipher)
		return decrypted_data

	@staticmethod
	def __create_cipher(bin_key):
		return AES.new(bin_key, AES.MODE_EAX, nonce=bytes(32))

	def __create_hmac(self):
		return HMAC.new(bytes(32), self.__ciphertext, SHA3_256)

	def __verify_hmac(self):
		hmac = self.__create_hmac()
		hmac.verify(self.__hmac)

	def __decrypt_data(self, cipher):
		try:
			decrypted_data = deserialize_from_string(cipher.decrypt(self.__ciphertext))
			return decrypted_data
		except:
			raise self.DecryptionError("Decryption failed")

	class DecryptionError(Exception):
		pass
