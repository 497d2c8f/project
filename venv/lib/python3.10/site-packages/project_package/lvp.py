from .hash_data import hash_data, HASH_LENGTH
from .sign import Sign, SIGN_PK_LENGTH
from .check  import check_data_type, check_bytes_length


class LVP:

	__lvp = []
	__v_id = None

	def __init__(self, lvp, v_id):
		LVP.__check_lvp_items(lvp)
		LVP.__check_v_id(v_id)
		self.__lvp = [hash_data(vp_sign_pk) for vp_sign_pk in lvp]
		self.__v_id = v_id

	def check(self, vp_sign_pk):
		vp_is_in_lvp = self.__check_vp_is_in_lvp(vp_sign_pk)
		return vp_is_in_lvp

	def append(self, lvp):
		LVP.__check_lvp_items(lvp)
		LVP.__check_lvp_is_empty(lvp)
		self.__lvp += [hash_data(vp_sign_pk) for vp_sign_pk in lvp if hash_data(vp_sign_pk) not in self.__lvp]

	def get_list(self):
		return self.__lvp

	def get_v_id(self):
		return self.__v_id

	def __check_lvp_items(lvp):
		if not isinstance(lvp, list):
			raise TypeError('тип lvp должен быть list')
		for vp_sign_pk in lvp:
			Sign._check_sign_pk(vp_sign_pk)

	def __check_lvp_is_empty(lvp):
		if not lvp:
			raise ValueError('необходимо передать непустой список')

	def __check_v_id(v_id):
		check_data_type(v_id, bytes)
		check_bytes_length(v_id, HASH_LENGTH)

	def __check_vp_is_in_lvp(self, vp_sign_pk):
		Sign._check_sign_pk(vp_sign_pk)
		if hash_data(vp_sign_pk) in self.__lvp or not self.__lvp:
			return True
		else:
			return False
