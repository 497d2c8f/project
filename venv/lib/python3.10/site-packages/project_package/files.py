from .serialization import *
from Crypto.Random import get_random_bytes
from .ciphertext import Ciphertext
from .sign import Sign
from .key import Key
import fnmatch
import shutil
import pickle
import os
import io


CWD = os.getcwd()
#CWD = os.path.dirname(os.path.normpath(sys.executable))		# Раскомментить перед созданием исполняемого файла
VOTINGS_WD = os.path.join(CWD, 'votings')


__all__ = [
	'CWD',
	'VOTINGS_WD',
	'write_file',
	'read_file',
	'delete_paths',
	'get_filepaths',
	'get_file_like_object',
	'format_path',
	'read_keys_file',
	'write_keys_file',
	'get_voting_dirpath',
	'get_voting_filepath',
	'get_keys_public_filepath'
]


def write_file(path, file_key=None, **new_data):
	if os.path.dirname(path) and not os.path.isdir(os.path.dirname(path)):
		os.makedirs(os.path.dirname(path))
	data = {}
	try:
		with open(path, 'rb') as file:
			ct = deserialize_from_file(file)
			data = ct.decrypt(file_key)
	except FileNotFoundError:
		pass
	with open(path, 'wb') as file:
		data = {**data, **new_data}
		ct = Ciphertext(data, file_key)
		serialize_to_file(ct, file)


def read_file(path, file_key=None):
	with open(path, 'rb') as file:
		data = read_file_object(file, file_key)
		return data


def read_file_object(file_object, file_key=None):
	ct = deserialize_from_file(file_object)
	data = ct.decrypt(file_key)
	return data


def delete_paths(*patterns, directory=CWD, del_dir=False):
	if del_dir:
		try:
			shutil.rmtree(directory)
		except:
			return None
	else:
		filepaths = get_filepaths(*patterns, directory=directory, full_path=True)
		for file in filepaths:
			for pattern in patterns:
				if fnmatch.fnmatch(os.path.basename(file), pattern):
					os.remove(file)


def get_filepaths(*patterns, directory=CWD, full_path=False):
	filepaths = []
	all_filepaths = []
	try:
		all_filepaths = os.listdir(directory)
	except:
		return None
	for filepath in all_filepaths:
		for pattern in patterns:
			if fnmatch.fnmatch(filepath, pattern):
				filepaths.append(os.path.join(directory, filepath) if full_path else filepath)
	return filepaths


def get_file_like_object(file_key=None, **data):
	ct = Ciphertext(data, file_key)
	return io.BytesIO(serialize_to_string(ct))


def format_path(path):
	formatted_path = path.replace('\'', '').strip()
	return formatted_path


def read_keys_file():
	answer = format_path(input('\nПеретащите сюда Ваш файл с ключами или введите "1", чтобы создать новый, и нажмите Enter: '))
	if answer == '1':
		return write_keys_file()
	else:
		return read_file(answer)


def write_keys_file():
	sign_pk, sign_sk = Sign.create_sign_keypair()
	kem_pk, kem_sk = Key.create_kem_keypair()
	keys = {
		'main_key': get_random_bytes(32),
		'sign_pk': sign_pk,
		'sign_sk': sign_sk,
		'kem_pk': kem_pk,
		'kem_sk': kem_sk
	}
	filepath = os.path.join(CWD, f'keys__{sign_pk[0:8].hex()}')
	write_file(
		filepath,
		**keys
	)
	print(f'\nФайл с ключами "{CWD}/keys__{sign_pk[0:8].hex()}" успешно создан.')
	return keys


def get_voting_dirpath():
	print('\n')
	voting_dir_names = get_filepaths('*', directory=VOTINGS_WD)
	dir_names = []
	for i, dir_name in enumerate(voting_dir_names):
		dir_names.append(dir_name)
		print(f'{i}: {dir_name}')
	option = int(input('\nВыберите голосование и нажмите Enter: '))
	voting_dirpath = os.path.join(VOTINGS_WD, dir_names[option])
	return voting_dirpath


def get_voting_filepath(voting):
	voting_filepath = os.path.join(VOTINGS_WD, voting.get_v_id()[0:8].hex(), f'voting__{voting.get_v_id()[0:8].hex()}')
	return voting_filepath


def get_keys_public_filepath(keys_file_data):
	keys_public_filepath = os.path.join(CWD, f'keys_public__{keys_file_data["sign_pk"][0:8].hex()}')
	return keys_public_filepath
